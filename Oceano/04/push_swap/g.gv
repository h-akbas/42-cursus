digraph G {
    Mmain [label="int main(int argc, char **argv)" shape=box];
    ->
    append_node [label="void append_node(t_stack **stack, int nbr)" shape=box];
    count_words [label="static int count_words(char const *s, char c)" shape=box];
    error_free [label="void error_free(t_stack **a, char **argv, bool is_)" shape=box];
    error_repetition [label="int error_repetition(t_stack *a, int nbr)" shape=box];
    error_syntax [label="int error_syntax(char *str)" shape=box];
    fill_result [label="static char **fill_result(char **res, char const *s, char c)" shape=box];
    find_highest [label="static t_stack *find_highest(t_stack *stack)" shape=box];
    find_last_node [label="t_stack *find_last_node(t_stack *head)" shape=box];
    find_smallest [label="t_stack *find_smallest(t_stack *stack)" shape=box];
    finish_rotation [label="void finish_rotation(t_stack **stack, t_stack *top)" shape=box];
    free_all [label="static char **free_all(char **result, int j)" shape=box];
    free_args [label="void free_args(char **argv)" shape=box];
    free_stack [label="void free_stack(t_stack **stack)" shape=box];
    ft_atol [label="static long ft_atol(const char *str)" shape=box];
    ft_split [label="char **ft_split(char const *s, char c)" shape=box];
    ft_strlcpy [label="static size_t ft_strlcpy(char *dst, const char *src, size_t size)" shape=box];
    handle_five [label="void handle_five(t_stack **a, t_stack **b)" shape=box];
    init_nodes [label="void init_nodes(t_stack *a, t_stack *b)" shape=box];
    move_nodes [label="static void move_nodes(t_stack **a, t_stack **b)" shape=box];
    pa [label="void pa(t_stack **a, t_stack **b, bool checker)" shape=box];
    pb [label="void pb(t_stack **b, t_stack **a, bool checker)" shape=box];
    push [label="static void push(t_stack **dest, t_stack **src)" shape=box];
    push_swap [label="void push_swap(t_stack **a, t_stack **b)" shape=box];
    ra [label="void ra(t_stack **a, bool checker)" shape=box];
    rb [label="void rb(t_stack **b, bool checker)" shape=box];
    return_cheapest [label="t_stack *return_cheapest(t_stack *stack)" shape=box];
    reverse_rotate [label="static void reverse_rotate(t_stack **stack)" shape=box];
    reverse_rotate_both [label="static void reverse_rotate_both(t_stack **a, t_stack **b)" shape=box];
    rotate [label="static void rotate(t_stack **stack)" shape=box];
    rotate_both [label="static void rotate_both(t_stack **a, t_stack **b)" shape=box];
    rr [label="void rr(t_stack **a, t_stack **b, bool checker)" shape=box];
    rra [label="void rra(t_stack **a, bool checker)" shape=box];
    rrb [label="void rrb(t_stack **b, bool checker)" shape=box];
    rrr [label="void rrr(t_stack **a, t_stack **b, bool checker)" shape=box];
    sa [label="void sa(t_stack **a, bool checker)" shape=box];
    sb [label="void sb(t_stack **b, bool checker)" shape=box];
    set_cheapest [label="void set_cheapest(t_stack *b)" shape=box];
    set_current_position [label="void set_current_position(t_stack *stack)" shape=box];
    set_price [label="void set_price(t_stack *a, t_stack *b)" shape=box];
    set_target_node [label="static void set_target_node(t_stack *a, t_stack *b)" shape=box];
    ss [label="void ss(t_stack **a, t_stack **b, bool checker)" shape=box];
    stack_init [label="void stack_init(t_stack **a, char **argv, bool fla)" shape=box];
    stack_len [label="int stack_len(t_stack *stack)" shape=box];
    stack_sorted [label="bool stack_sorted(t_stack *stack)" shape=box];
    swap [label="static void swap(t_stack **head)" shape=box];
    t_stack [label= "t_stack" shape=box];
    tiny_sort [label="void tiny_sort(t_stack **a)" shape=box];
    
    Mmain -> main;
    append_node -> stack_utils;
    count_words -> split.c;
    error_free -> error_free.c;
    error_repetition -> error_free.c;
    error_syntax -> error_free.c;
    fill_result -> split.c;
    find_highest -> tiny_sort.c;
    find_last_node -> stack_utils.c;
    find_smallest -> stack_utils.c;
    finish_rotation -> push_swap_command.c;
    free_all -> split.c;
    free_args -> error_free.c;
    free_stack -> error_free.c;
    ft_atol -> stack_init.c;
    ft_split -> split.c;
    ft_strlcpy -> split.c;
    handle_five -> tiny_sort.c;
    init_nodes -> push_swap_init.c;
    move_nodes -> push_swap_command.c;
    pa -> push_command.c;
    pb -> push_command.c;
    push -> push_command.c;
    push_swap -> push_swap_command.c;
    ra -> rotate_command.c;
    rb -> rotate_command.c;
    return_cheapest -> stack_utils.c;
    reverse_rotate -> reverse_rotate_command.c;
    reverse_rotate_both -> push_swap_command.c;
    rotate -> rotate_command.c;
    rotate_both -> push_swap_command.c;
    rr -> rotate_command.c;
    rra -> reverse_rotate_command.c;
    rrb -> reverse_rotate_command.c;
    rrr -> reverse_rotate_command.c;
    sa -> swap_command.c;
    sb -> swap_command.c;
    set_cheapest -> push_swap_init.c;
    set_current_position -> push_swap_init.c;
    set_price -> push_swap_init.c;
    set_target_node -> push_swap_init.c;
    ss -> swap_command.c;
    stack_init -> stack_init.c;
    stack_len -> stack_utils.c;
    stack_sorted -> tiny_sort.c;
    swap -> swap_command.c;
    t_stack -> push_swap.h;
    tiny_sort -> tiny_sort.c;
}

